{\rtf1\ansi\ansicpg1252\cocoartf1504\cocoasubrtf820
{\fonttbl\f0\fnil\fcharset0 Calligraphic810BT-Roman;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\sl288\slmult1\pardirnatural

\f0\i\fs22 \cf0 \'93Do as I say, not as I do.\'94\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\sl288\slmult1\pardirnatural

\i0 \cf0 \
\
\ul I have fallen into the bad habit of using boost::shared_ptr for everything.\ulnone \
This is bad for performance because shared_ptr\'92s ref count increment/decrement is also atomic, which is just slowing that I don\'92t need.  This is also bad for clarity/debugging (and performance) because I have less control over the end-of-life of resources and they can be de-allocated at unclear or un-opportune times.  The end-of-life problem might actually be causing some of the mysterious slow passes through the engine\'92s primary update/draw loop.\
\
Update:  2017-3-27\
I went ahead and changed all boost::shared_ptr to std::shared_ptr, but there are still too many in use.\
\
\
\ul All of my factories should be returning unique_ptrs, or keeping unique_ptrs and returning raw const pointers.\ulnone \
I\'92ll change my behavior now, and will look into changing some managers/factories in the wild.  I did come across one case where I couldn\'92t switch from shared_ptr to unique_ptr, and that was where the factory had a particular instance that was not created but shared.  In that case, you can\'92t have two different types of pointers for a type out in the wild, so they all were kept as shared_ptrs.\
\
Update, 2017-5-20:\
I went ahead and fixed this in all of the factory classes, which in my case are not really factories by \'91warehouses\'92.\
\
\
\ul I need to start using make_shared() and make_unique().\ulnone \
I\'92ll change my behavior now, but there are too many to change in the wild, and no good way to automate it.\
\
\
\ul I need to use \'93using\'94 instead of \'93typedef\'94\
\ulnone I\'92ll change my behavior now, and will change existing code as I stumble upon it.  As of May 2017, I think all uses have been replaced.\ul \
\
\
I need to use auto for stack vars and non-virtual function return types.\
\ulnone I\'92ll change my behavior now, but there are too many to change in the wild, and no good way to automate it.\
\
\
\ul I have not been using brace initialization, and I should.\ulnone \
The benefits of curly brace initialization, or aggregate initialization, such as preventing of narrowing and illegal inits, out-way the possible problems, such as types with initializer list constructors.  Unfortunately, I didn\'92t have this in mind when starting to write the code.  So almost all of the code uses value initialization (parens).  I\'92ll change my behavior but will not go back and re-write the older code.  So expect to see a mix of initialization types.\
\
\
\ul I have places in the code where class functions return references to local members causing dangling.\ulnone \
These need to be changed into functions that return data via reference parameter.  I don\'92t know of a good way to search for this, so I\'92ll change them as I stumble into them in the wild.  I suppose I could write some kind of regular expression to find them\'85I\'92ll put it on my TODO list.  This isn\'92t such a big problem because I am pretty disciplined about my use of returned resources.  As of May 2017, all but two or three cases exist, and those cases that do still exist need to be that way.  Usage is disciplined enough to make it safe.\
\
\
\ul I used a trailing underscore to indicate a member variable instead of the prefix m_.\ulnone \
I had a reason for doing this, but it must have been a stupid one because\'85seriously, why break such a normative style.  At this point there is simply too much code in the codebase, making the change unfeasible.  I\'92ll just keep on as I have been to keep the style consistent.\
\
\
\ul I made function names start with a capital letter.\ulnone \
I had a reason for doing this, but it must have been a stupid one, again.  There is no excuse to break such a normative style.  At this point there is simply too much code in the codebase, making the change unfeasible.  I\'92ll just keep on as I have been to keep the style consistent.\
\
\
\ul My singletons use shared_ptr.\ulnone \
All my singletons use shared_ptrs for the instance pointer.  This was a (flawed) design decision made early on when I was shared_ptr happy.  I should take the time to change this.\
\
\
\ul I miss-use the singleton pattern.\ulnone \
I have used singletons whenever I needed a \'91manager-of-resources\'92 or \'91collection-of-similar-operations\'92 type class.  That by itself is not really a problem.  The problem is that I use these singletons as global access points which is rightly bad code smell, seeing as I should have instead been passing around pointers or references to these objects where needed.  The engine code is even conducive to passing these classes around because of how the Stage classes act as collectors/managers of resources, but I didn\'92t think of that soon enough.  Now there are scattered uses of singletons all over the codebase that would require too much work to change into proper passing or Acquire() Release() semantics.  So I\'92m not to going to bother and continue to use the singletons as I have been.  The smell isn\'92t that bad.\
\
\
\ul I set no limit on line lengths.\ulnone \
I was spoiled early in my career and never got in the habit, and I should have.  Now there is too much code to go back and change.  I\'92ll try and change my style from here on out to limit to 100 characters per line.\
}