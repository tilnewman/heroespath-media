{\rtf1\ansi\ansicpg1252\cocoartf1504\cocoasubrtf810
{\fonttbl\f0\fnil\fcharset0 Calligraphic810BT-Roman;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\sl288\slmult1\pardirnatural

\f0\i\fs22 \cf0 	\'93Do as I say, not as I do.\'94\

\i0 \
\
\ul I have fallen into the bad habit of using boost::shared_ptr for everything.\ulnone \
This is bad for performance because shared_ptr wraps it\'92s increment/decrement atomically so multi-threading is safe, but I don\'92t need that because the game engine is single-threaded.  This is also bad for clarity/debugging (and performance) because I have less control over the end-of-life of resources and they can be de-allocated at unclear or un-opportune times.  The end-of-life problem is actually not so bad, since the Stage system automatically acquires/releases most resources at Stage construction/destruction time, and not during normal time-critical frame-rate sensitive looping.  However, this still should be changed to use shared_ptr only sparingly when ownership is actually shared, such as when a Stage keeps a member shared_ptr and also stores it in the EntityList with EntityAdd().  These places should acquire a new shared_ptr to inc the ref count, then use raw pointers or references to pass everything around.  For example, the many manager classes should perform this inc/deliver-raw-ptr behavior.  There is one advantage that should be mentioned when using pointers of any kind everywhere, and that is the ease of eliminating includes to make builds faster.  I should also change from using boost::shared_ptr to the std::shared_ptr since I\'92m working in C++14.\
\
Update:  2017-3-27\
I went ahead and changed all boost::shared_ptr to std::shared_ptr.\
\
\
\ul All of my factories should be returning unique_ptrs instead, or keeping unique_ptrs and returning raw const pointers.\ulnone \
I\'92ll change my behavior now, and will look into changing some managers/factories in the wild.  I did come across one case where I couldn\'92t switch from shared_ptr to unique_ptr, and that was where the factory had a particular instance that was not created but shared.  In that case, you can\'92t have two different types of pointers for a type out in the wild, so they all were kept as shared_ptrs.\
\
\
\ul I need to start using make_shared() and make_unique().\ulnone \
I\'92ll change my behavior now, but there are too many to change in the wild, and no good way to automate it.\
\
\
\ul I need to use \'93using\'94 instead of \'93typedef\'94\
\ulnone I\'92ll change my behavior now, and will change existing code as I stumble upon it.\ul \
\
\
I need to use auto for stack vars and non-virtual function return types.\
\ulnone I\'92ll change my behavior now, but there are too many to change in the wild, and no good way to automate it.\
\
\
\ul I have not been using brace initialization, and I should.\ulnone \
The benefits of curly brace initialization, or aggregate initialization, such as preventing of narrowing and illegal inits, out-way the possible problems, such as types with initializer list constructors.  Unfortunately, I didn\'92t have this in mind when starting to write the code.  So almost all of the code uses value initialization (parens).  I\'92ll change my behavior but will not go back and re-write the older code.  So expect to see a mix of initialization types.  \
\
\
\ul I have places in the code where class functions return references to local members causing dangling.\ulnone \
These need to be changed into functions that return data via reference parameter.  I don\'92t know of a good way to search for this, so I\'92ll change them as I stumble into them in the wild.  I suppose I could write some kind of regular expression to find them\'85I\'92ll put it on my TODO list.  This isn\'92t such a big problem because I am pretty disciplined about my use of returned resources.\
\
\
\ul I used a trailing underscore to indicate a member variable instead of the prefix m_.\ulnone \
I had a reason for doing this, but it must have been a stupid one because\'85seriously, why break such a normative one.  At this point there is simply too much code in the codebase, making the change unfeasible.  I\'92ll just keep on.\
\
\
\ul I made function names start with a capital letter.\ulnone \
I had a reason for doing this, but it must have been a stupid one because\'85seriously, why break such a normative one.  At this point there is simply too much code in the codebase, making the change unfeasible.  I\'92ll just keep on.\
\
\
\ul My singletons are not thread safe.\ulnone \
All my singletons, and there are many, use shared_ptrs and the generic singleton::Instance() function which has the line \{ if (instance_.get() == nullptr) \} -which is not thread safe because two threads could race to find the value of .get().  This was a design decision early on since the engine is single-threaded.  The idea was to prefer simplicity.  This is also not much of an issue because a reference to almost all of my singletons are kept in main.cpp to prevent resources from thrashing.  Hmm.  I was forced to say \'91almost all\'92 instead of all.  Maybe I should work on that\'85\
\
\
\ul I miss-use singletons.\ulnone \
I have used singletons whenever I needed a \'91manager-of-resources\'92 or \'91collection-of-similar-operations\'92 type class.  That by itself is not really a problem.  The problem is that I use these singletons as global access points which is rightly bad code smell, seeing as I should have instead been passing around pointers or references to these objects where needed.  The engine code is even conducive to passing these classes around because of how the Stage classes act as collectors of resources, but I didn\'92t think of that soon enough.  Now there are scattered uses of singletons all over the codebase that would require too much work to change into proper passing or Acquire() Release() semantics.  So I\'92m not to going to bother doing all of that work, and continue to use the singletons as I have been.  The smell isn\'92t that bad. }