{\rtf1\ansi\ansicpg1252\cocoartf1504\cocoasubrtf830
{\fonttbl\f0\fnil\fcharset0 Calligraphic810BT-Roman;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\sl288\slmult1\pardirnatural

\f0\fs48 \cf0 Code Smell
\i\fs22 \
\'93Do as I say, not as I do.\'94\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\sl288\slmult1\pardirnatural

\i0 \cf0 \
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\sl288\slmult1\pardirnatural
\cf0 \ul \ulc0 I have fallen into the bad habit of using boost::shared_ptr for everything.\ulnone \
This is bad for performance because shared_ptr\'92s ref count increment/decrement is atomic, which is just slowing that I don\'92t need.  This is also bad for clarity/debugging because I end up with less control over the end-of-life times.  In the beginning, I had a vision for how the engine used resources that worked perfectly with shared_ptr semantics, but in the end, this well intentioned design simply turned into an excuse to use shared_ptr that was not sufficient.  The end-of-life problem might actually be causing some of the mysterious slow passes through the engine\'92s primary update/draw loop.\
\
Update:  2017-3-27\
I went ahead and changed all boost::shared_ptr to std::shared_ptr, but that doesn\'92t address the problem of them being used in the first place.\
\
Update: 2017-8-10\
Since the last pass reading this document, I have removed almost all of the shared_ptrs.\
\
\
\
\ul I need to start using make_shared() and make_unique().\ulnone \
I\'92ll change my behavior now, but there are too many to change in the wild, and no good way to automate it.\
\
Update, 2017-8-19:\
Many cases have been changed, but an overhaul to search for all new\'92s and replace them has not yet been done.\
\
\ul \
\
I need to use auto for stack vars and non-virtual function return types.\
\ulnone I\'92ll change my behavior now, but there are too many to change in the wild, and no good way to automate it.\
\
\
\
\ul I have not been using brace initialization, and I should.\ulnone \
The benefits of curly brace initialization, or aggregate initialization, such as preventing of narrowing and illegal inits, out-way the possible problems, such as types with initializer list constructors.  Unfortunately, I didn\'92t have this in mind when starting to write the code.  So almost all of the code uses value initialization (parens).  I\'92ll change my behavior but will not go back and re-write the older code.  So expect to see a mix of initialization types.\
\
\
\
\ul I used a trailing underscore to indicate a member variable instead of the prefix m_.\ulnone \
I had a reason for doing this, but it must have been a stupid one because I can\'92t remember what it was.  There is no excuse for breaking such a universally adopted style.  At this point there is simply too much code in the codebase, and I\'92m fearful of such a sweeping regex replace.  I\'92ll probably start changing the style in new classes.  I\'92ll keep the style consistent within a compilation unit.\
\
\
\ul I made function names start with a capital letter.\ulnone \
I had a reason for doing this, but it must have been a stupid one, because, again, I can\'92t remember what it was.  There is no excuse to break such universal style.  At this point there is simply too much code in the codebase, making the change unfeasible.  I\'92ll just keep on as I have been to keep the style consistent.\
\
\
\
\ul I\'92m using singletons.\ulnone \
I have used singletons whenever I needed a \'91manager-of-resources\'92 or \'91collection-of-similar-operations\'92 type class.  The engine code is even conducive to passing manager references around because of how the Stage classes act as collectors of resources, but I didn\'92t think of that soon enough.  Now there are scattered uses of singletons all over the codebase that would require too much work to change into proper passing or Acquire() Release() semantics.  So I\'92m not to going to bother and continue to use the singletons as I have been.\
\
\
\
\ul I set no limit on line lengths.\ulnone \
I was spoiled early in my career and never got in the habit of limiting line length, but there is no excuse good enough.  Now there is too much code to go back and change.  I\'92ll change my style to limit on 100 characters per line from here on.  I should be using clang-format everywhere, but I had problems getting it to work\'85  I\'92ll fix code as I find it.\
\
\
\
\ul I haven\'92t been consistent with my usage of brackets.\ulnone \
I was consistently using the Allman style, then, for some stupid reason, I switched to not using brackets for single indented lines.  I have since switched back to always using Allman brackets but there is a lot of code out there where they are missing.  Too much to go back and fix it all now.  I\'92ll put them back as I find them.\
\
\
\
\ul Types in variable names.\ulnone \
For some reason I felt the need to put \'93Vec\'94 at the end of vector names and \'93Enum\'94 at the end of enum names, etc.  I think this was originally an alternative to using the postfix \'93List\'94, but it became pervasive and in the end, silly.\
\
\
\
\ul Lack of Unit Tests\
\ulnone There are reasons why a lot of the game code is not unit testable, but there is no excuse for not setting up a unit testing framework from the beginning and using it as much as possible.  I\'92m adding unit tests as I go, as of September 2017.\
\
\
\
\ul Testability\ulnone \
I think in an effort to give functions useful names and clear responsibilities, I fail to limit those responsibilities so the result is easily testable.  I need to get better at making smaller functions with limited parameters that are easily unit testable.\
\
\
\
\ul Boolean Function Parameters\ulnone \
I use Boolean function parameters everywhere, and I need to stop.  My modus-operandi is to add a boolean flag to functions wherever possible to make a function more versatile, but versatility does not equal simplicity or testability\'85\
\
\
\
\ul begin() and end()\
\ulnone I haven\'92t been using them and as a default I should.  I\'92ll change now but there are a lot of them lying around.\
\
\
\
\ul Override\ulnone \
I haven\'92t been using the override keyword.  I\'92ll start now but there is a ton of code that doesn\'92t use it.\
\
\
\ul Primitive Obsession and a Lack of Strong Types\ulnone \
I have used the \'93using\'94 keyword plenty to name my own types, but not in a way that creates strong types.  For example, stats::Trait_t is used in everywhere and it smells.  Also, the use of Hungarian notation for the \'93_t\'94 is a smell in itself, but I have a reason for it:  I capitalize the first letter of functions (another smell) so the \'93_t\'94 is useful.  Anyway, I\'92ve started a process for using strong types with a type wrapper called \'93StrongType\'94 and \'93StrongNumericType\'94, but I\'92m not sure if I will ever go back and use it in all the places I should have.  A lack of strong types is definitely a smell in this codebase.\
}